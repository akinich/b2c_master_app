-- =====================================================
-- MULTI-APP STREAMLIT DATABASE SCHEMA
-- =====================================================
-- This schema works with Supabase's built-in auth.users table
-- Run this in your Supabase SQL Editor

-- =====================================================
-- 1. ROLES TABLE
-- =====================================================
CREATE TABLE IF NOT EXISTS roles (
    id SERIAL PRIMARY KEY,
    role_name VARCHAR(50) UNIQUE NOT NULL,
    description TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Insert default roles
INSERT INTO roles (role_name, description) VALUES
    ('Admin', 'Full access to all modules and admin panel'),
    ('Manager', 'Access to most modules except user management'),
    ('User', 'Limited access to basic modules')
ON CONFLICT (role_name) DO NOTHING;

-- =====================================================
-- 2. USER PROFILES TABLE
-- =====================================================
-- Links to Supabase auth.users and adds our custom fields
CREATE TABLE IF NOT EXISTS user_profiles (
    id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    full_name VARCHAR(255),
    role_id INTEGER REFERENCES roles(id) NOT NULL,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- =====================================================
-- 3. MODULES TABLE
-- =====================================================
-- Defines all available mini apps
CREATE TABLE IF NOT EXISTS modules (
    id SERIAL PRIMARY KEY,
    module_name VARCHAR(100) NOT NULL,
    module_key VARCHAR(50) UNIQUE NOT NULL, -- Used in code to reference module
    description TEXT,
    icon VARCHAR(50), -- Icon name or emoji
    is_active BOOLEAN DEFAULT TRUE,
    display_order INTEGER DEFAULT 0, -- For controlling sidebar order
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Insert your 6 modules (customize as needed)
INSERT INTO modules (module_name, module_key, description, icon, display_order) VALUES
    ('PDF Generator', 'pdf_generator', 'Create custom PDF documents', 'üìÑ', 1),
    ('PDF Merger', 'pdf_merger', 'Combine multiple PDF files', 'üìé', 2),
    ('API Data Fetcher', 'api_fetcher', 'Fetch data from website API', 'üîå', 3),
    ('Report Generator', 'report_generator', 'Generate business reports', 'üìä', 4),
    ('Data Export', 'data_export', 'Export data to various formats', 'üíæ', 5),
    ('Module 6', 'module_6', 'Description for module 6', '‚öôÔ∏è', 6)
ON CONFLICT (module_key) DO NOTHING;

-- =====================================================
-- 4. ROLE PERMISSIONS TABLE
-- =====================================================
-- Defines which roles can access which modules
CREATE TABLE IF NOT EXISTS role_permissions (
    id SERIAL PRIMARY KEY,
    role_id INTEGER REFERENCES roles(id) ON DELETE CASCADE,
    module_id INTEGER REFERENCES modules(id) ON DELETE CASCADE,
    can_access BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    UNIQUE(role_id, module_id)
);

-- Default permissions
-- Admin gets all modules
INSERT INTO role_permissions (role_id, module_id, can_access)
SELECT 
    (SELECT id FROM roles WHERE role_name = 'Admin'),
    id,
    TRUE
FROM modules
ON CONFLICT (role_id, module_id) DO NOTHING;

-- Manager gets all except user management (if you add that module later)
INSERT INTO role_permissions (role_id, module_id, can_access)
SELECT 
    (SELECT id FROM roles WHERE role_name = 'Manager'),
    id,
    TRUE
FROM modules
WHERE module_key != 'user_management'
ON CONFLICT (role_id, module_id) DO NOTHING;

-- User gets limited modules (customize based on your needs)
INSERT INTO role_permissions (role_id, module_id, can_access)
SELECT 
    (SELECT id FROM roles WHERE role_name = 'User'),
    id,
    TRUE
FROM modules
WHERE module_key IN ('pdf_generator', 'pdf_merger')
ON CONFLICT (role_id, module_id) DO NOTHING;

-- =====================================================
-- 5. ACTIVITY LOGS TABLE
-- =====================================================
-- Tracks all user actions for audit trail
CREATE TABLE IF NOT EXISTS activity_logs (
    id BIGSERIAL PRIMARY KEY,
    user_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    user_email VARCHAR(255), -- Store email in case user is deleted
    action_type VARCHAR(50) NOT NULL, -- e.g., 'login', 'logout', 'module_access', 'export_data'
    module_key VARCHAR(50), -- Which module was accessed (if applicable)
    description TEXT, -- Detailed description of the action
    ip_address INET, -- User's IP address
    user_agent TEXT, -- Browser/device info
    success BOOLEAN DEFAULT TRUE, -- Whether the action succeeded
    metadata JSONB, -- Store additional data as needed
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Index for faster queries
CREATE INDEX IF NOT EXISTS idx_activity_logs_user_id ON activity_logs(user_id);
CREATE INDEX IF NOT EXISTS idx_activity_logs_created_at ON activity_logs(created_at DESC);
CREATE INDEX IF NOT EXISTS idx_activity_logs_action_type ON activity_logs(action_type);
CREATE INDEX IF NOT EXISTS idx_activity_logs_module_key ON activity_logs(module_key);

-- =====================================================
-- 6. USEFUL VIEWS
-- =====================================================

-- View: User Details with Role Information
CREATE OR REPLACE VIEW user_details AS
SELECT 
    u.id,
    u.email,
    up.full_name,
    r.role_name,
    up.is_active,
    up.created_at,
    up.updated_at
FROM auth.users u
LEFT JOIN user_profiles up ON u.id = up.id
LEFT JOIN roles r ON up.role_id = r.id;

-- View: User Permissions (which modules each user can access)
CREATE OR REPLACE VIEW user_module_permissions AS
SELECT 
    u.id as user_id,
    u.email,
    up.full_name,
    r.role_name,
    m.module_name,
    m.module_key,
    m.icon,
    rp.can_access,
    m.display_order
FROM auth.users u
JOIN user_profiles up ON u.id = up.id
JOIN roles r ON up.role_id = r.id
JOIN role_permissions rp ON r.id = rp.role_id
JOIN modules m ON rp.module_id = m.id
WHERE up.is_active = TRUE AND m.is_active = TRUE
ORDER BY m.display_order;

-- =====================================================
-- 7. ROW LEVEL SECURITY (RLS) POLICIES
-- =====================================================
-- Enable RLS on tables (best practice for Supabase)

-- Enable RLS
ALTER TABLE user_profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE activity_logs ENABLE ROW LEVEL SECURITY;
ALTER TABLE role_permissions ENABLE ROW LEVEL SECURITY;

-- Policy: Users can read their own profile
CREATE POLICY "Users can view own profile" ON user_profiles
    FOR SELECT
    USING (auth.uid() = id);

-- Policy: Users can view their own activity logs
CREATE POLICY "Users can view own activity logs" ON activity_logs
    FOR SELECT
    USING (auth.uid() = user_id);

-- Policy: Service role (your backend) can do everything
-- Note: You'll use service_role key in your Streamlit app for admin operations

-- =====================================================
-- 8. FUNCTIONS FOR COMMON OPERATIONS
-- =====================================================

-- Function: Log user activity
CREATE OR REPLACE FUNCTION log_activity(
    p_user_id UUID,
    p_action_type VARCHAR,
    p_module_key VARCHAR DEFAULT NULL,
    p_description TEXT DEFAULT NULL,
    p_metadata JSONB DEFAULT NULL
)
RETURNS VOID AS $$
BEGIN
    INSERT INTO activity_logs (
        user_id,
        user_email,
        action_type,
        module_key,
        description,
        metadata
    )
    SELECT 
        p_user_id,
        email,
        p_action_type,
        p_module_key,
        p_description,
        p_metadata
    FROM auth.users
    WHERE id = p_user_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function: Get user's accessible modules
CREATE OR REPLACE FUNCTION get_user_modules(p_user_id UUID)
RETURNS TABLE (
    module_id INTEGER,
    module_name VARCHAR,
    module_key VARCHAR,
    description TEXT,
    icon VARCHAR,
    display_order INTEGER
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        m.id,
        m.module_name,
        m.module_key,
        m.description,
        m.icon,
        m.display_order
    FROM modules m
    JOIN role_permissions rp ON m.id = rp.module_id
    JOIN user_profiles up ON rp.role_id = up.role_id
    WHERE up.id = p_user_id
        AND up.is_active = TRUE
        AND m.is_active = TRUE
        AND rp.can_access = TRUE
    ORDER BY m.display_order;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- =====================================================
-- 9. TRIGGER: Auto-update updated_at timestamp
-- =====================================================
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_user_profiles_updated_at
    BEFORE UPDATE ON user_profiles
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- =====================================================
-- SCHEMA SETUP COMPLETE!
-- =====================================================
-- Next steps:
-- 1. Get your Supabase URL and service_role key
-- 2. Add them to Streamlit secrets
-- 3. Start building the Python app!
